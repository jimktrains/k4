record Person
  byte[2] id
  int8    position_in_line

op >(Person {position_in_line a}, Person {position_in_line b}):
  return a > b

# op >(Person a, Person b):
#   int8 x <- a.position_in_line
#   int8 y <- b.position_in_line
#   return a > y

def random(byte8 state) => byte8 state, byte output:
  # x^7 + x + 1
  const byte poly = 0b10000011
	state = (state >> 1) ^ poly;
  ouput = state

# The syntax for a Slice parameter can include that multiple items being 
# extracted from the Slice being passed in; one of the extracted parameters
# may be prefixed with an @ symbol, symbolizing where the the rest of the
# slice being passed in, that is the elements not being extracted. 
# For example: [1,2,3,4] passed into:
#   [x,@rest]         => x=1, rest=[2,3,4]
#   [@rest,x]         => x=4, rest=[1,2,3]
#   [x,y,@rest]       => x=1, y=2, rest=[3,4]
#   [x,@rest,y]       => x=1, y=4, rest=[2,3]
#   [w,x,y,z,@rest]   => w=1, x=2, y=3, z=4, rest=[]
#   [w,x,y,z,a,@rest] => compiler error
#
# So, what we're doing here for bubble short, is to take an array, extracted 
# the last element, partially sort the whole array, including the extracted
# element. We then do this again, without the extracted element. If we
# have no elements in the rest of the slice, then we terminate.
def bubble_sort(Slice{T} [@rest,x]):
  if rest.length != 0:
    bubble_partial_sort([rest, x])
    bubble_sort(rest)

# This function partially sort the passed in slice by extracting the last
# two elements, swapping them if nessecary. Swap happens in-place, so
# we can then partially sort the remainer of the slice by passing in
# the rest prepended to the first extracted value. (Values can only be
# concatented in the order extracted: rest;y is a compiler error below.
def bubble_partial_sort(Slice{T} [@rest,x,y]):
  if x > y:
    swap x y
  if rest.length != 0:
    bubble_partial_sort([rest,x])

# Since slice extracts act like references, assigning to them
# will change the value in the array.
def double(Slice<size>{T} [x,@xs], Slice<size>{T} [y,@ys]):
  y <= x + x
  if xs.length != 0 and ys.length != 0:
    double(xs, ys)

# Reduce the array by extracting the first element, adding it to the
# carry. If there is nothing left to recurse on, we return the
# carry.
def sum(Slice{T} [x,@xs], T carry):
  carry += x
  if xs.length != 0:
    return sum(xs, carry)
  return carry

Array<10>{Person} queue

byte state = 0x01

for person in queue:
  output, state <- random(state)
  person.position_in_line <- (int8)output

bubble_sort(queue)
